//
//  EllipticalPDE.swift
//
//
//  Created by Christopher Fredregill on 3/13/22.
//

import simd

/// An elliptical partial differential equation to be solved numerically.
public struct EllipticalPDE: DiscretizedPDE {

    public var lhs: DiscretizedLHS

    public var rhs: DiscretizedRHS

    /// The `UnsolvedMesh` consisting of points at which the elliptical PDE is to be determined numerically.
    /// May consist entirely of uninitialized/unknown points (as generated by a mesh factory method).
    public let mesh: UnsolvedMesh

    /// The boundary conditions constraining the solution to the elliptical PDE.
    /// These can be given in terms of functions of spatial coordinates around the boundaries of the mesh,
    /// or as derivative boundary conditions (involving finite difference approximations at boundary points).
    public let boundaryCondition: BoundaryCondition

    /// Creates a new `EllipticalPDE` which can be solved numerically, subject to certain boundary conditions.
    ///
    /// - Parameters:
    ///   - lhs: The discretized "left-hand side" expression involving unknowns in the PDE mesh.
    ///   - rhs: The discretized "right-hand side" expression involving any functions of spatial coordinates in the PDE.
    ///   - mesh: The mesh on which the PDE is to be solved.
    ///   - boundaryCondition: The discretized Dirichlet boundary conditions to which the solution is subject.
    ///
    /// Derivative boundary conditions are supported through the `lhs` and `rhs` parameters.
    public init(
        lhs: @escaping DiscretizedLHS,
        rhs: @escaping DiscretizedRHS,
        mesh: UnsolvedMesh,
        boundaryCondition: @escaping BoundaryCondition
    ) {
        self.lhs = lhs
        self.rhs = rhs
        self.mesh = mesh
        self.boundaryCondition = boundaryCondition
    }

    /// The `UnsolvedMesh` once initialized by the given `BoundaryCondition`.
    /// This mesh may contain both known and unknown points.
    /// Both known and unknown points within the unsolved mesh will be used to construct a linear system.
    lazy var unsolvedMesh: UnsolvedMesh = {
        return mesh.applyBoundaryCondition(boundaryCondition)
    }()

    /// A wrapper for a sparse system of linear equations to be solved numerically.
    /// The linear system's left-hand side is determined by the `lhs` and `rhs` expressions, as well as the mesh.
    /// The right-hand side (the `b`-vector, in a linear system `Ax = b`) is determined by the `bVector` function.
    lazy var linearSystem: LinearSystem = {
        return LinearSystem.from(unsolvedMesh: unsolvedMesh, pde: self)
    }()

    /// Solves the elliptical PDE numerically, using a linear system corresponding to the problem description.
    /// - Returns: A `SolvedMesh` consisting solely of known points within the mesh on which the PDE was so be solved.
    public mutating func solve() -> SolvedMesh {
        var bValues = bVector(unsolvedMesh: unsolvedMesh)
        return unsolvedMesh.solve(&linearSystem, bValues: &bValues)
    }

    func contains(_ location: simd_int3) -> Bool {
        return mesh.contains(location)
    }

    /// Assembles the `b`-vector of a linear system `Ax = b` built from the problem description.
    /// - Parameter unsolvedMesh: The unsolved mesh from which the corresponding `LinearSystem` is constructed.
    /// - Returns: An array of values corresponding to linear combinations of the unknowns in the problem (one per row).
    ///
    /// Traverses over the unknown points within the unsolved mesh in `x`-, `y`-, and then `z`-order. At each unknown:
    /// * Computes a "left-hand side" linear combination involving the values at any adjacent known points in the mesh
    /// * Computes a "right-hand side" linear combination involving values at any adjacent known points in the mesh
    /// * Subtracts the "right-hand" from the "left-hand" value to produce a `b`-vector entry in the system `Ax = b`.
    private func bVector(unsolvedMesh: UnsolvedMesh) -> [Double] {
        var bValues = [Double]()
        for row in unsolvedMesh.unknowns {
            for column in row {
                for point in column where point.ordinal != nil {
                    let (value, coefficients) = rhs(point.indices)
                    let rhs: Double = value - coefficients.reduce(0.0, coefficientReducer(unsolvedMesh.knowns))
                    let lhs: Double = lhs(point.indices).reduce(0.0, coefficientReducer(unsolvedMesh.knowns))
                    bValues.append(rhs - lhs)
                }
            }
        }
        return bValues
    }
}
